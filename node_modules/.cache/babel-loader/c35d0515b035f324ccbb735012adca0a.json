{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _objectSpread from \"@babel/runtime/helpers/objectSpread2\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _createSuper from \"@babel/runtime/helpers/createSuper\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _excluded = [\"children\", \"style\", \"vertical\", \"getRootRef\", \"getRef\", \"platform\", \"filled\", \"splitCol\", \"panel\", \"getPanelNode\", \"window\", \"document\"];\nimport { createScopedElement } from \"../../lib/jsxRuntime\";\nimport * as React from 'react';\nimport { getClassName } from \"../../helpers/getClassName\";\nimport { classNames } from \"../../lib/classNames\";\nimport { transitionEndEventName, transitionStartEventName } from \"../View/View\";\nimport { withContext } from \"../../hoc/withContext\";\nimport { withPlatform } from \"../../hoc/withPlatform\";\nimport { withPanelContext } from \"../Panel/withPanelContext\";\nimport { setRef } from \"../../lib/utils\";\nimport { SplitColContext } from \"../SplitCol/SplitCol\";\nimport { TooltipContainer } from \"../Tooltip/TooltipContainer\";\nimport { withDOM } from \"../../lib/dom\";\nimport { IOS } from \"../../lib/platform\";\nimport { warnOnce } from \"../../lib/warnOnce\";\nvar warn = warnOnce('FixedLayout');\n\nvar FixedLayout = /*#__PURE__*/function (_React$Component) {\n  _inherits(FixedLayout, _React$Component);\n\n  var _super = _createSuper(FixedLayout);\n\n  function FixedLayout() {\n    var _this;\n\n    _classCallCheck(this, FixedLayout);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"state\", {\n      position: 'absolute',\n      top: null,\n      bottom: null,\n      width: ''\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"el\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"onMountResizeTimeout\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"onViewTransitionStart\", function (e) {\n      var panelScroll = e.detail.scrolls[_this.props.panel] || 0; // support for unstable ViewInfinite\n\n      if (Array.isArray(panelScroll)) {\n        var scrolls = panelScroll;\n        panelScroll = scrolls[scrolls.length - 1];\n      }\n\n      var fromPanelHasScroll = _this.props.panel === e.detail.from && panelScroll > 0;\n      var toPanelHasScroll = _this.props.panel === e.detail.to && panelScroll > 0; // если переход назад на Android - анимация только у панели с которой уходим (detail.from), и подстраиваться под скролл надо только на ней\n      // на iOS переход между панелями горизонтальный, поэтому там нужно подстраивать хедеры на обеих панелях\n\n      var panelAnimated = _this.props.platform === IOS || !(_this.props.panel === e.detail.to && e.detail.isBack); // Для панелей, с которых уходим всегда выставляется скролл\n      // Для панелей на которые приходим надо смотреть, есть ли браузерный скролл и применяется ли к ней анимация перехода:\n\n      if (fromPanelHasScroll || toPanelHasScroll && _this.canTargetPanelScroll && panelAnimated) {\n        _this.setState({\n          position: 'absolute',\n          top: _this.props.vertical === 'top' || fromPanelHasScroll ? _this.el.offsetTop + panelScroll : null,\n          bottom: _this.props.vertical === 'bottom' && !fromPanelHasScroll ? -panelScroll : null,\n          width: ''\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"onViewTransitionEnd\", function () {\n      _this.setState({\n        position: null,\n        top: null,\n        bottom: null\n      });\n\n      _this.doResize();\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"doResize\", function () {\n      var colRef = _this.props.splitCol.colRef;\n\n      if (colRef && colRef.current) {\n        var node = colRef.current;\n        var width = node.offsetWidth;\n\n        _this.setState({\n          width: \"\".concat(width, \"px\"),\n          position: null\n        });\n      } else {\n        _this.setState({\n          width: '',\n          position: null\n        });\n      }\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"getRef\", function (element) {\n      _this.el = element;\n      setRef(element, _this.props.getRootRef);\n    });\n\n    return _this;\n  }\n\n  _createClass(FixedLayout, [{\n    key: \"document\",\n    get: function get() {\n      return this.props.document;\n    }\n  }, {\n    key: \"window\",\n    get: function get() {\n      return this.props.window;\n    }\n  }, {\n    key: \"currentPanel\",\n    get: function get() {\n      var elem = this.props.getPanelNode();\n\n      if (process.env.NODE_ENV === 'development' && !elem) {\n        warn('Panel element not found');\n      }\n\n      return elem;\n    }\n  }, {\n    key: \"canTargetPanelScroll\",\n    get: function get() {\n      var panelEl = this.currentPanel;\n\n      if (!panelEl) {\n        return true; // Всегда предпологаем, что может быть скролл в случае, если нет document\n      }\n\n      return panelEl.scrollHeight > panelEl.clientHeight;\n    }\n  }, {\n    key: \"componentDidMount\",\n    value: function componentDidMount() {\n      var _this2 = this;\n\n      this.onMountResizeTimeout = setTimeout(function () {\n        return _this2.doResize();\n      });\n      this.window.addEventListener('resize', this.doResize);\n      this.document.addEventListener(transitionStartEventName, this.onViewTransitionStart);\n      this.document.addEventListener(transitionEndEventName, this.onViewTransitionEnd);\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function componentWillUnmount() {\n      clearTimeout(this.onMountResizeTimeout);\n      this.window.removeEventListener('resize', this.doResize);\n      this.document.removeEventListener(transitionStartEventName, this.onViewTransitionStart);\n      this.document.removeEventListener(transitionEndEventName, this.onViewTransitionEnd);\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      var _this$props = this.props,\n          children = _this$props.children,\n          style = _this$props.style,\n          vertical = _this$props.vertical,\n          getRootRef = _this$props.getRootRef,\n          getRef = _this$props.getRef,\n          platform = _this$props.platform,\n          filled = _this$props.filled,\n          splitCol = _this$props.splitCol,\n          panel = _this$props.panel,\n          getPanelNode = _this$props.getPanelNode,\n          window = _this$props.window,\n          document = _this$props.document,\n          restProps = _objectWithoutProperties(_this$props, _excluded);\n\n      return createScopedElement(TooltipContainer, _extends({}, restProps, {\n        fixed: true,\n        ref: this.getRef,\n        vkuiClass: classNames(getClassName('FixedLayout', platform), _defineProperty({\n          'FixedLayout--filled': filled\n        }, \"FixedLayout--\".concat(vertical), !!vertical)),\n        style: _objectSpread(_objectSpread({}, style), this.state)\n      }), createScopedElement(\"div\", {\n        vkuiClass: \"FixedLayout__in\",\n        ref: getRef\n      }, children));\n    }\n  }]);\n\n  return FixedLayout;\n}(React.Component);\n\nexport default withContext(withPlatform(withPanelContext(withDOM(FixedLayout))), SplitColContext, 'splitCol');","map":{"version":3,"sources":["../../../src/components/FixedLayout/FixedLayout.tsx"],"names":["warn","warnOnce","FixedLayout","React","Component","position","top","bottom","width","elem","process","panelEl","setTimeout","clearTimeout","panelScroll","e","Array","scrolls","fromPanelHasScroll","toPanelHasScroll","panelAnimated","colRef","node","setRef","children","style","vertical","getRootRef","getRef","platform","filled","splitCol","panel","getPanelNode","window","document","restProps","classNames","getClassName","withContext","withPlatform","withPanelContext","withDOM"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { getClassName } from '../../helpers/getClassName';\nimport { classNames } from '../../lib/classNames';\nimport { transitionEndEventName, TransitionStartEventDetail, transitionStartEventName } from '../View/View';\nimport { withContext } from '../../hoc/withContext';\nimport { HasPlatform, HasRef, HasRootRef } from '../../types';\nimport { withPlatform } from '../../hoc/withPlatform';\nimport { withPanelContext } from '../Panel/withPanelContext';\nimport { setRef } from '../../lib/utils';\nimport { SplitColContext, SplitColContextProps } from '../SplitCol/SplitCol';\nimport { TooltipContainer } from '../Tooltip/TooltipContainer';\nimport { PanelContextProps } from '../Panel/PanelContext';\nimport { DOMProps, withDOM } from '../../lib/dom';\nimport { IOS } from '../../lib/platform';\nimport { warnOnce } from '../../lib/warnOnce';\nimport './FixedLayout.css';\n\nexport interface FixedLayoutProps extends\n  React.HTMLAttributes<HTMLDivElement>,\n  HasRootRef<HTMLDivElement>,\n  HasRef<HTMLDivElement>,\n  HasPlatform {\n  vertical?: 'top' | 'bottom';\n  /**\n   * Это свойство определяет, будет ли фон компонента окрашен в цвет фона контента.\n   * Это часто необходимо для фиксированных кнопок в нижней части экрана.\n   */\n  filled?: boolean;\n  /**\n   * @ignore\n   */\n  splitCol?: SplitColContextProps;\n}\n\nexport interface FixedLayoutState {\n  position: 'absolute' | null;\n  top: number;\n  bottom: number;\n  width: string;\n}\n\nconst warn = warnOnce('FixedLayout');\n\nclass FixedLayout extends React.Component<FixedLayoutProps & DOMProps & PanelContextProps, FixedLayoutState> {\n  state: FixedLayoutState = {\n    position: 'absolute',\n    top: null,\n    bottom: null,\n    width: '',\n  };\n\n  el: HTMLDivElement;\n\n  private onMountResizeTimeout: number;\n\n  get document() {\n    return this.props.document;\n  }\n\n  get window() {\n    return this.props.window;\n  }\n\n  get currentPanel(): HTMLElement {\n    const elem = this.props.getPanelNode();\n\n    if (process.env.NODE_ENV === 'development' && !elem) {\n      warn('Panel element not found');\n    }\n\n    return elem;\n  }\n\n  get canTargetPanelScroll() {\n    const panelEl = this.currentPanel;\n    if (!panelEl) {\n      return true; // Всегда предпологаем, что может быть скролл в случае, если нет document\n    }\n    return panelEl.scrollHeight > panelEl.clientHeight;\n  }\n\n  componentDidMount() {\n    this.onMountResizeTimeout = setTimeout(() => this.doResize());\n    this.window.addEventListener('resize', this.doResize);\n\n    this.document.addEventListener(transitionStartEventName, this.onViewTransitionStart);\n    this.document.addEventListener(transitionEndEventName, this.onViewTransitionEnd);\n  }\n\n  componentWillUnmount() {\n    clearTimeout(this.onMountResizeTimeout);\n    this.window.removeEventListener('resize', this.doResize);\n\n    this.document.removeEventListener(transitionStartEventName, this.onViewTransitionStart);\n    this.document.removeEventListener(transitionEndEventName, this.onViewTransitionEnd);\n  }\n\n  onViewTransitionStart: EventListener = (e: CustomEvent<TransitionStartEventDetail>) => {\n    let panelScroll = e.detail.scrolls[this.props.panel] || 0;\n\n    // support for unstable ViewInfinite\n    if (Array.isArray(panelScroll)) {\n      const scrolls = panelScroll as number[];\n      panelScroll = scrolls[scrolls.length - 1];\n    }\n\n    const fromPanelHasScroll = this.props.panel === e.detail.from && panelScroll > 0;\n    const toPanelHasScroll = this.props.panel === e.detail.to && panelScroll > 0;\n\n    // если переход назад на Android - анимация только у панели с которой уходим (detail.from), и подстраиваться под скролл надо только на ней\n    // на iOS переход между панелями горизонтальный, поэтому там нужно подстраивать хедеры на обеих панелях\n    const panelAnimated = this.props.platform === IOS || !(this.props.panel === e.detail.to && e.detail.isBack);\n\n    // Для панелей, с которых уходим всегда выставляется скролл\n    // Для панелей на которые приходим надо смотреть, есть ли браузерный скролл и применяется ли к ней анимация перехода:\n    if (fromPanelHasScroll || toPanelHasScroll && this.canTargetPanelScroll && panelAnimated) {\n      this.setState({\n        position: 'absolute',\n        top: this.props.vertical === 'top' || fromPanelHasScroll ? this.el.offsetTop + panelScroll : null,\n        bottom: this.props.vertical === 'bottom' && !fromPanelHasScroll ? -panelScroll : null,\n        width: '',\n      });\n    }\n  };\n\n  onViewTransitionEnd: VoidFunction = () => {\n    this.setState({\n      position: null,\n      top: null,\n      bottom: null,\n    });\n\n    this.doResize();\n  };\n\n  doResize = () => {\n    const { colRef } = this.props.splitCol;\n\n    if (colRef && colRef.current) {\n      const node: HTMLElement = colRef.current;\n      const width = node.offsetWidth;\n\n      this.setState({ width: `${width}px`, position: null });\n    } else {\n      this.setState({ width: '', position: null });\n    }\n  };\n\n  getRef: React.RefCallback<HTMLDivElement> = (element) => {\n    this.el = element;\n    setRef(element, this.props.getRootRef);\n  };\n\n  render() {\n    const {\n      children,\n      style,\n      vertical,\n      getRootRef,\n      getRef,\n      platform,\n      filled,\n      splitCol,\n      panel,\n      getPanelNode,\n      window,\n      document,\n      ...restProps\n    } = this.props;\n\n    return (\n      <TooltipContainer\n        {...restProps}\n        fixed\n        ref={this.getRef}\n        vkuiClass={classNames(getClassName('FixedLayout', platform), {\n          'FixedLayout--filled': filled,\n          [`FixedLayout--${vertical}`]: !!vertical,\n        })}\n        style={{ ...style, ...this.state }}\n      >\n        <div vkuiClass=\"FixedLayout__in\" ref={getRef}>{children}</div>\n      </TooltipContainer>\n    );\n  }\n}\n\nexport default withContext(\n  withPlatform(withPanelContext(withDOM<FixedLayoutProps>(FixedLayout))),\n  SplitColContext,\n  'splitCol',\n);\n"]},"metadata":{},"sourceType":"module"}