{"ast":null,"code":"import _extends from \"@babel/runtime/helpers/extends\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nvar _excluded = [\"children\", \"getScrollToLeft\", \"getScrollToRight\", \"showArrows\", \"scrollAnimationDuration\", \"hasMouse\", \"getRef\"];\nimport { createScopedElement } from \"../../lib/jsxRuntime\";\nimport * as React from 'react';\nimport { usePlatform } from \"../../hooks/usePlatform\";\nimport { getClassName } from \"../../helpers/getClassName\";\nimport { withAdaptivity } from \"../../hoc/withAdaptivity\";\nimport HorizontalScrollArrow from \"./HorizontalScrollArrow\";\nimport { easeInOutSine } from \"../../lib/fx\";\nimport { useEventListener } from \"../../hooks/useEventListener\";\nimport { useExternRef } from \"../../hooks/useExternRef\";\n/**\r\n * timing method\r\n */\n\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n/**\r\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\r\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\r\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\r\n */\n\n\nvar SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll(_ref) {\n  var scrollElement = _ref.scrollElement,\n      getScrollPosition = _ref.getScrollPosition,\n      animationQueue = _ref.animationQueue,\n      onScrollToRightBorder = _ref.onScrollToRightBorder,\n      onScrollEnd = _ref.onScrollEnd,\n      onScrollStart = _ref.onScrollStart,\n      initialScrollWidth = _ref.initialScrollWidth,\n      _ref$scrollAnimationD = _ref.scrollAnimationDuration,\n      scrollAnimationDuration = _ref$scrollAnimationD === void 0 ? SCROLL_ONE_FRAME_TIME : _ref$scrollAnimationD;\n\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n  /**\r\n   * максимальное значение сдвига влево\r\n   */\n\n\n  var maxLeft = initialScrollWidth - scrollElement.offsetWidth;\n  var startLeft = scrollElement.scrollLeft;\n  var endLeft = getScrollPosition(startLeft);\n  onScrollStart();\n\n  if (endLeft >= maxLeft) {\n    onScrollToRightBorder();\n    endLeft = maxLeft;\n  }\n\n  var startTime = now();\n\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n\n    var time = now();\n    var elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n    var value = easeInOutSine(elapsed);\n    var currentLeft = startLeft + (endLeft - startLeft) * value;\n    scrollElement.scrollLeft = Math.ceil(currentLeft);\n\n    if (scrollElement.scrollLeft !== Math.max(0, endLeft)) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n\nvar HorizontalScroll = function HorizontalScroll(props) {\n  var children = props.children,\n      getScrollToLeft = props.getScrollToLeft,\n      getScrollToRight = props.getScrollToRight,\n      showArrows = props.showArrows,\n      scrollAnimationDuration = props.scrollAnimationDuration,\n      hasMouse = props.hasMouse,\n      getRef = props.getRef,\n      restProps = _objectWithoutProperties(props, _excluded);\n\n  var _React$useState = React.useState(false),\n      _React$useState2 = _slicedToArray(_React$useState, 2),\n      canScrollLeft = _React$useState2[0],\n      setCanScrollLeft = _React$useState2[1];\n\n  var _React$useState3 = React.useState(false),\n      _React$useState4 = _slicedToArray(_React$useState3, 2),\n      canScrollRight = _React$useState4[0],\n      setCanScrollRight = _React$useState4[1];\n\n  var isCustomScrollingRef = React.useRef(false);\n  var scrollerRef = useExternRef(getRef);\n  var animationQueue = React.useRef([]);\n  var platform = usePlatform();\n\n  function scrollTo(getScrollPosition) {\n    var scrollElement = scrollerRef.current;\n    animationQueue.current.push(function () {\n      var _scrollElement$firstE;\n\n      return doScroll({\n        scrollElement: scrollElement,\n        getScrollPosition: getScrollPosition,\n        animationQueue: animationQueue.current,\n        onScrollToRightBorder: function onScrollToRightBorder() {\n          return setCanScrollRight(false);\n        },\n        onScrollEnd: function onScrollEnd() {\n          return isCustomScrollingRef.current = false;\n        },\n        onScrollStart: function onScrollStart() {\n          return isCustomScrollingRef.current = true;\n        },\n        initialScrollWidth: (scrollElement === null || scrollElement === void 0 ? void 0 : (_scrollElement$firstE = scrollElement.firstElementChild) === null || _scrollElement$firstE === void 0 ? void 0 : _scrollElement$firstE.scrollWidth) || 0,\n        scrollAnimationDuration: scrollAnimationDuration\n      });\n    });\n\n    if (animationQueue.current.length === 1) {\n      animationQueue.current[0]();\n    }\n  }\n\n  var onscroll = React.useCallback(function () {\n    if (showArrows && hasMouse && scrollerRef.current && !isCustomScrollingRef.current) {\n      var scrollElement = scrollerRef.current;\n      setCanScrollLeft(scrollElement.scrollLeft > 0);\n      setCanScrollRight(scrollElement.scrollLeft + scrollElement.offsetWidth < scrollElement.scrollWidth);\n    }\n  }, [hasMouse]);\n  var scrollEvent = useEventListener('scroll', onscroll);\n  React.useEffect(function () {\n    return scrollEvent.add(scrollerRef.current);\n  }, []);\n  React.useEffect(onscroll, [scrollerRef, children]);\n  return createScopedElement(\"div\", _extends({}, restProps, {\n    vkuiClass: getClassName('HorizontalScroll', platform)\n  }), showArrows && hasMouse && canScrollLeft && createScopedElement(HorizontalScrollArrow, {\n    direction: \"left\",\n    onClick: function onClick() {\n      return scrollTo(getScrollToLeft);\n    }\n  }), showArrows && hasMouse && canScrollRight && createScopedElement(HorizontalScrollArrow, {\n    direction: \"right\",\n    onClick: function onClick() {\n      return scrollTo(getScrollToRight);\n    }\n  }), createScopedElement(\"div\", {\n    vkuiClass: \"HorizontalScroll__in\",\n    ref: scrollerRef\n  }, createScopedElement(\"div\", {\n    vkuiClass: \"HorizontalScroll__in-wrapper\"\n  }, children)));\n};\n\nHorizontalScroll.defaultProps = {\n  showArrows: true\n};\nexport default withAdaptivity(HorizontalScroll, {\n  hasMouse: true\n});","map":{"version":3,"sources":["../../../src/components/HorizontalScroll/HorizontalScroll.tsx"],"names":["performance","Date","SCROLL_ONE_FRAME_TIME","scrollElement","getScrollPosition","animationQueue","onScrollToRightBorder","onScrollEnd","onScrollStart","initialScrollWidth","scrollAnimationDuration","maxLeft","startLeft","endLeft","startTime","now","time","elapsed","Math","value","easeInOutSine","currentLeft","requestAnimationFrame","HorizontalScroll","children","getScrollToLeft","getScrollToRight","showArrows","hasMouse","getRef","restProps","props","canScrollLeft","setCanScrollLeft","React","canScrollRight","setCanScrollRight","isCustomScrollingRef","scrollerRef","useExternRef","platform","usePlatform","doScroll","onscroll","scrollEvent","useEventListener","getClassName","scrollTo","withAdaptivity"],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { usePlatform } from '../../hooks/usePlatform';\nimport { getClassName } from '../../helpers/getClassName';\nimport { withAdaptivity, AdaptivityProps } from '../../hoc/withAdaptivity';\nimport HorizontalScrollArrow from './HorizontalScrollArrow';\nimport { easeInOutSine } from '../../lib/fx';\nimport { useEventListener } from '../../hooks/useEventListener';\nimport { useExternRef } from '../../hooks/useExternRef';\nimport { HasRef } from '../../types';\nimport './HorizontalScroll.css';\n\ninterface ScrollContext {\n  scrollElement: HTMLElement | null;\n  scrollAnimationDuration: number;\n  animationQueue: VoidFunction[];\n  getScrollPosition: (currentPosition: number) => number;\n  onScrollToRightBorder: VoidFunction;\n  onScrollEnd: VoidFunction;\n  onScrollStart: VoidFunction;\n  /**\n   * Начальная ширина прокрутки.\n   * В некоторых случаях может отличаться от текущей ширины прокрутки из-за transforms: translate\n   */\n  initialScrollWidth: number;\n}\n\nexport interface HorizontalScrollProps extends\n  React.HTMLAttributes<HTMLDivElement>,\n  AdaptivityProps,\n  HasRef<HTMLDivElement> {\n  /**\n   * Функция для расчета величины прокрутки при клике на левую стрелку.\n   */\n  getScrollToLeft?: (currentPosition: number) => number;\n  /**\n   * Функция для расчета величины прокрутки при клике на правую стрелку.\n   */\n  getScrollToRight?: (currentPosition: number) => number;\n  showArrows?: boolean;\n  scrollAnimationDuration?: number;\n}\n\n/**\n * timing method\n */\nfunction now() {\n  return performance && performance.now ? performance.now() : Date.now();\n}\n\n/**\n * Код анимации скрола, на основе полифила: https://github.com/iamdustan/smoothscroll\n * Константа взята из полифила (468), на дизайн-ревью уточнили до 250\n * @var {number} SCROLL_ONE_FRAME_TIME время анимации скролла\n */\nconst SCROLL_ONE_FRAME_TIME = 250;\n\nfunction doScroll({\n  scrollElement,\n  getScrollPosition,\n  animationQueue,\n  onScrollToRightBorder,\n  onScrollEnd,\n  onScrollStart,\n  initialScrollWidth,\n  scrollAnimationDuration = SCROLL_ONE_FRAME_TIME,\n}: ScrollContext) {\n  if (!scrollElement || !getScrollPosition) {\n    return;\n  }\n\n  /**\n   * максимальное значение сдвига влево\n   */\n  const maxLeft = initialScrollWidth - scrollElement.offsetWidth;\n\n  let startLeft = scrollElement.scrollLeft;\n  let endLeft = getScrollPosition(startLeft);\n\n  onScrollStart();\n\n  if (endLeft >= maxLeft) {\n    onScrollToRightBorder();\n    endLeft = maxLeft;\n  }\n\n  const startTime = now();\n\n  (function scroll() {\n    if (!scrollElement) {\n      onScrollEnd();\n      return;\n    }\n\n    const time = now();\n    const elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);\n\n    const value = easeInOutSine(elapsed);\n\n    const currentLeft = startLeft + (endLeft - startLeft) * value;\n    scrollElement.scrollLeft = Math.ceil(currentLeft);\n\n    if (scrollElement.scrollLeft !== Math.max(0, endLeft)) {\n      requestAnimationFrame(scroll);\n      return;\n    }\n\n    onScrollEnd();\n    animationQueue.shift();\n    if (animationQueue.length > 0) {\n      animationQueue[0]();\n    }\n  })();\n}\n\nconst HorizontalScroll: React.FC<HorizontalScrollProps> = (props: HorizontalScrollProps) => {\n  const {\n    children,\n    getScrollToLeft,\n    getScrollToRight,\n    showArrows,\n    scrollAnimationDuration,\n    hasMouse,\n    getRef,\n    ...restProps\n  } = props;\n\n  const [canScrollLeft, setCanScrollLeft] = React.useState(false);\n  const [canScrollRight, setCanScrollRight] = React.useState(false);\n\n  const isCustomScrollingRef = React.useRef(false);\n\n  const scrollerRef = useExternRef(getRef);\n\n  const animationQueue = React.useRef<VoidFunction[]>([]);\n\n  const platform = usePlatform();\n\n  function scrollTo(getScrollPosition: (offset: number) => number) {\n    const scrollElement = scrollerRef.current;\n\n    animationQueue.current.push(() => doScroll({\n      scrollElement,\n      getScrollPosition,\n      animationQueue: animationQueue.current,\n      onScrollToRightBorder: () => setCanScrollRight(false),\n      onScrollEnd: () => isCustomScrollingRef.current = false,\n      onScrollStart: () => isCustomScrollingRef.current = true,\n      initialScrollWidth: scrollElement?.firstElementChild?.scrollWidth || 0,\n      scrollAnimationDuration,\n    }));\n    if (animationQueue.current.length === 1) {\n      animationQueue.current[0]();\n    }\n  }\n\n  const onscroll = React.useCallback(() => {\n    if (showArrows && hasMouse && scrollerRef.current && !isCustomScrollingRef.current) {\n      const scrollElement = scrollerRef.current;\n\n      setCanScrollLeft(scrollElement.scrollLeft > 0);\n      setCanScrollRight(scrollElement.scrollLeft + scrollElement.offsetWidth < scrollElement.scrollWidth);\n    }\n  }, [hasMouse]);\n\n  const scrollEvent = useEventListener('scroll', onscroll);\n  React.useEffect(() => scrollEvent.add(scrollerRef.current), []);\n  React.useEffect(onscroll, [scrollerRef, children]);\n\n  return (\n    <div {...restProps} vkuiClass={getClassName('HorizontalScroll', platform)}>\n      {showArrows && hasMouse && canScrollLeft &&\n      <HorizontalScrollArrow\n        direction=\"left\"\n        onClick={() => scrollTo(getScrollToLeft)}\n      />\n      }\n      {showArrows && hasMouse && canScrollRight &&\n      <HorizontalScrollArrow\n        direction=\"right\"\n        onClick={() => scrollTo(getScrollToRight)}\n      />\n      }\n      <div vkuiClass=\"HorizontalScroll__in\" ref={scrollerRef}>\n        <div vkuiClass=\"HorizontalScroll__in-wrapper\">\n          {children}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nHorizontalScroll.defaultProps = {\n  showArrows: true,\n};\n\nexport default withAdaptivity(HorizontalScroll, {\n  hasMouse: true,\n});\n"]},"metadata":{},"sourceType":"module"}